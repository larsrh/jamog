
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 * Copyright 2009 Lars Hupel, Torben Maack, Sylvester Tremmel                *
 *                                                                           *
 * This file is part of Jamog.                                               *
 *                                                                           *
 * Jamog is free software: you can redistribute it and/or modify             *
 * it under the terms of the GNU General Public License as published by      *
 * the Free Software Foundation; version 3.                                  *
 *                                                                           *
 * Jamog is distributed in the hope that it will be useful,                  *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              *
 * GNU General Public License for more details.                              *
 *                                                                           *
 * You should have received a copy of the GNU General Public License         *
 * along with Jamog. If not, see <http://www.gnu.org/licenses/>.             *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

package core.build.checking;

import core.build.checking.types.Type;
import core.exception.EvaluationException;
import core.signal.Signal;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import static core.exception.EvaluationException.Type.*;

/**
 * This interface represents an abstract syntax tree for expressions. Objects
 * of implementing classes will usually be generated by {@link ExpressionParser}.
 * Note that most implementing classes are independent from our {@link Type own}
 * type system.
 * Most implementing classes will provide a constructor which takes <i>n</i>
 * {@link Expression} objects, where <i>n</i> corresponds to their arity.
 * @param <T> stands for the type of the result, namely the return value of
 * {@link #evaluate(java.util.Map)}.
 * @see ExpressionParser#parse(java.lang.String)
 * @see ExpressionParser#parse(java.lang.String, java.lang.Class)
 * @see ExpressionParser#parse(java.lang.String, core.build.checking.Type)
 * @author torben
 */
public interface Expression<T>
{

	/**
	 * Represents a unary expression, which means it has exactly one input parameter.
	 * @param <I> type of the input parameter
	 * @param <E> type of the result
	 * @see Expression
	 */
	public static abstract class UnaryExpression<I, E> implements Expression<E>
	{
		protected final Expression<I> in;

		public UnaryExpression(Expression<I> in)
		{
			this.in = in;
		}

		@Override public String toString()
		{
			return getClass().getSimpleName()+"("+in.toString()+")";
		}

	}

	/**
	 * Represents a binary expression, which means it has exactly two input parameters.
	 * @param <L> type of the first (left) parameter
	 * @param <R> type of the second (right) parameter
	 * @param <E> type of the result
	 * @see Expression
	 */
	public static abstract class BinaryExpression<L, R, E> implements Expression<E>
	{
		protected final Expression<L> left;
		protected final Expression<R> right;

		public BinaryExpression(Expression<L> left, Expression<R> right)
		{
			this.left = left;
			this.right = right;
		}

		@Override public String toString()
		{
			return getClass().getSimpleName()+"("+left.toString()+","+right.toString()+")";
		}
	}

	/**
	 * Converts a {@link List} of {@link Expression}s to a {@link List} of their
	 * respective values, which means, on all elements {@link #evaluate(java.util.Map)}
	 * will be called and the results will be packed into a {@link List} and
	 * returned.
	 * @param <T>
	 */
	public static final class ListEval<T> implements Expression<List<T>>
	{

		private final List<Expression<? extends T>> exprs;

		public ListEval(List<Expression<? extends T>> exprs)
		{
			this.exprs = new ArrayList<Expression<? extends T>>(exprs);
		}

		@Override public List<T> evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			List<T> results = new ArrayList<T>(exprs.size());
			for (Expression<? extends T> expr : exprs)
				results.add(expr.evaluate(identifiers));
			return results;
		}

		@Override public String toString()
		{
			return new StringBuilder("ListEval(").append(exprs.toString()).append(")").toString();
		}

		public final List<Expression<? extends T>> getExpressions()
		{
			return Collections.unmodifiableList(exprs);
		}

	}

	/**
	 * Helper class to convert {@link String}s into (untyped) values.
	 * Following constants are provided:
	 * <ul>
	 *   <li>{@code keys}: returns the {@link Map#keySet() key set} of a {@link Map}</li>
	 *   <li>{@code values}: returns the {@link Map#values() value collection} of a {@link Map}</li>
	 *   <li>{@code ceil}: rounds a {@link BigDecimal} to the next bigger whole number</li>
	 *   <li>{@code log}: computes the binary logarithm of a {@link BigDecimal}</li>
	 *   <li>{@code if}: "if-then-else", takes a {@link Boolean} and returns second or third argument<br />
	 *       NOTE: currently not lazy!</li>
	 * </ul>
	 */
	public static final class Identifier implements Expression<Object>
	{
		private static final Map<String,Object> constants = new HashMap<String, Object>();

		static {
			constants.put("keys", new Call.Function() {
				@Override
				public Type[] getParameters() {
					return new Type[] { Type.getType(Map.class) };
				}

				@Override
				public Object invoke(Object... parameters) throws EvaluationException {
					return ((Map)parameters[0]).keySet();
				}
			});
			constants.put("values", new Call.Function() {
				@Override
				public Type[] getParameters() {
					return new Type[] { Type.getType(Map.class) };
				}

				@Override
				public Object invoke(Object... parameters) throws EvaluationException {
					return ((Map)parameters[0]).values();
				}
			});
			constants.put("ceil", new Call.Function() {
				@Override
				public Type[] getParameters() {
					return new Type[] { Type.BIG_DECIMAL };
				}

				@Override
				public Object invoke(Object... parameters) {
					// TODO: choose better expression
					return BigDecimal.valueOf(Math.ceil(((BigDecimal)parameters[0]).doubleValue()));
				}
			});
			constants.put("log", new Call.Function() {
				@Override
				public Type[] getParameters() {
					return new Type[] { Type.BIG_DECIMAL };
				}

				@Override
				public Object invoke(Object... parameters) throws EvaluationException {
					// TODO: choose better algorithm
					BigDecimal b = (BigDecimal)parameters[0];

					if (b.signum() <= 0)
						throw new EvaluationException(NEGATIVE_LOGARITHM);
					else if (b.compareTo(BigDecimal.ONE) == 0)
						return BigDecimal.ZERO;

					return BigDecimal.valueOf(Math.log(((BigDecimal)parameters[0]).doubleValue())/Math.log(2));
				}
			});
			constants.put("if", new Call.Function() {
				@Override
				public Type[] getParameters() {
					return new Type[] { Type.BOOLEAN, Type.OBJECT, Type.OBJECT };
				}

				@Override
				public Object invoke(Object... parameters) throws EvaluationException {
					return (Boolean)parameters[0] ? parameters[1] : parameters[2];
				}
			});
		}

		private final String identifier;

		public Identifier(String identifier)
		{
			this.identifier = identifier;
		}

		@Override public Object evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			if (constants.containsKey(identifier))
				return constants.get(identifier);
			if (identifiers.containsKey(identifier))
				return identifiers.get(identifier);
			throw new EvaluationException(identifier,IDENTIFIER_NOT_FOUND);
		}

		@Override public String toString()
		{
			return identifier;
		}

	}

	/**
	 * Provides index-based access to elements of an array or a {@link Collection}.
	 * If {@code in} denotes the target object, and {@code indexes} the array
	 * of indexes, this {@link Expression} behaves as following:
	 * {@code in[indexes[0]][indexes[1]]...[indexes[indexes.length-1]]}.
	 * Besides arrays, only instances {@link Collection} are allowed to be
	 * target objects, which means {@link Map}-access is not possible.
	 */
	public static final class Child extends UnaryExpression<Object, Object>
	{
		private final Expression<BigDecimal>[] indexes;

		@SuppressWarnings("unchecked") public Child(Expression<Object> in, int... indexes)
		{
			super(in);
			this.indexes = new Expression[indexes.length];
			for (int i=0;i<indexes.length;++i)
				this.indexes[i] = new Constant<BigDecimal>(BigDecimal.valueOf(indexes[i]));
		}

		@SuppressWarnings("unchecked") public Child(Expression<Object> in, Expression<BigDecimal>... indexes)
		{
			super(in);
			this.indexes = new Expression[indexes.length];
			System.arraycopy(indexes, 0, this.indexes, 0, indexes.length);
		}

		@Override public Object evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			Object value = in.evaluate(identifiers);
			for (Expression<BigDecimal> child : indexes)
				value = getChild(value, child.evaluate(identifiers).intValue());
			return value;
		}

		private final Object getChild(Object parent, int child) throws EvaluationException
		{
			if(parent instanceof Collection)
				return ((Collection)parent).toArray()[child];
			else if(parent instanceof Object[])
				return ((Object[])parent)[child];

			throw new EvaluationException("unsupported type");
		}

		@Override public String toString()
		{
			StringBuilder sb = new StringBuilder("(").append(in).append(")");
			for (Expression<?> child : indexes)
				sb.append('[').append(child).append(']');
			return sb.toString();
		}
	}

	/**
	 * Converts many objects into {@link BigDecimal}s. Number values will be
	 * converted into their {@link BigDecimal} representations, whereas
	 * collection-style objects can be traversed recursively to find out the
	 * size of a particular dimension.
	 * If a recursion is requested by the {@code dimension} parameter,
	 * {@link #evaluate(java.util.Map) evaluate} may return {@code -1} if a
	 * jagged array is encountered.
	 * At lowest level (which means no recursion is done), the following
	 * operations will be done:
	 * <table>
	 *   <tr>
	 *     <th>Target class</th><th>Behaviour</th>
	 *   </tr>
	 *   <tr><td>array</td><td>length</td></tr>
	 *   <tr><td>{@link Signal}</td><td>{@link Signal#size() width}</td></tr>
	 *   <tr><td>{@link Collection}</td><td>{@link Collection#size() size}</td></tr>
	 *   <tr><td>{@link Map}</td><td>{@link Map#size() size}</td></tr>
	 *   <tr><td>{@link BigDecimal}</td><td>identity</td></tr>
	 *   <tr><td>{@link Number}</td><td>{@link Number#doubleValue() to double}</td></tr>
	 * </table>
	 */
	public static final class Size extends UnaryExpression<Object, BigDecimal>
	{
		private final int dimension;

		public Size(Expression<Object> in)
		{
			this(in, 0);
		}

		public Size(Expression<Object> in, int dimension)
		{
			super(in);
			this.dimension = dimension;
		}

		@Override public String toString()
		{
			return new StringBuilder("Size_").append(dimension).append("(").append(in.toString()).append(")").toString();
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return rec(in.evaluate(identifiers), dimension);
		}

		private final BigDecimal rec(Object value, int dim) throws EvaluationException
		{
			if(dim != 0)
			{
				BigDecimal size = null;

				if(value instanceof Collection)
				{
					for(Object o : (Collection)value)
						if(size == null)
							size = rec(o, dim - 1);
						else if(size.compareTo(rec(o, dim - 1)) != 0)
							return BigDecimal.valueOf(-1);
				}
				else if(value instanceof Object[])
				{
					for(Object o : (Object[])value)
						if(size == null)
							size = rec(o, dim - 1);
						else if(size.compareTo(rec(o, dim - 1)) != 0)
							return BigDecimal.valueOf(-1);
				}
				else
					throw new EvaluationException("unsupported type");

				return size == null ? BigDecimal.ZERO : size;
			}
			else
			{
				if (value instanceof BigDecimal)
					return (BigDecimal) value;
				else if (value instanceof Number)
					return BigDecimal.valueOf(((Number)value).doubleValue());

				int size = DimensionMatcher.getDimension(value);
				if (size != -1)
					return BigDecimal.valueOf(size);

				throw new EvaluationException("unsupported type");
			}
		}
	}

	public static final class Constant<T> implements Expression<T>
	{
		private final T value;

		public Constant(T value)
		{
			this.value = value;
		}

		@Override public final T evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return value;
		}

		@Override public String toString()
		{
			return value.toString();
		}
	}

	public static final class Not extends UnaryExpression<Boolean, Boolean>
	{
		public Not(Expression<Boolean> in)
		{
			super(in);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return !in.evaluate(identifiers);
		}
	}

	public static final class Call extends BinaryExpression<Object, List<Object>, Object>
	{

		public static abstract class Function {
			protected abstract Object invoke(Object... parameters) throws EvaluationException;
			protected abstract Type[] getParameters();
		}

		public Call(Expression<Object> left, Expression<List<Object>> right)
		{
			super(left, right);
		}

		@SuppressWarnings("unchecked") @Override public final Object evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			Object callable = left.evaluate(identifiers);
			List<Object> params = right.evaluate(identifiers);

			if (callable instanceof Runnable && params.isEmpty()) {
				((Runnable)callable).run();
				return null;
			}
			else if (callable instanceof Callable<?> && params.isEmpty()) {
				try {
					return ((Callable<?>) callable).call();
				}
				catch (Exception ex) {
					throw new EvaluationException(ex);
				}
			}
			else if (callable instanceof Function) {
				Function f = (Function)callable;
				Type expectedParameters[] = f.getParameters();
				if (params.size() != expectedParameters.length)
					throw new EvaluationException("wrong parameter count");
				int i=0;
				for (Iterator<Object> iter = params.iterator();iter.hasNext();++i)
					if (!expectedParameters[i].canAssign(iter.next()))
						throw new EvaluationException("wrong parameter type");
				return f.invoke(params.toArray());
			}
			else if (callable instanceof Method) {
				try {
					return ((Method) callable).invoke(params.get(0),params.subList(1, params.size()).toArray());
				}
				catch (Exception ex) {
					throw new EvaluationException(ex);
				}
			}
			throw new EvaluationException("unknown target");
		}
	}

	public static final class Neg extends UnaryExpression<BigDecimal, BigDecimal>
	{
		public Neg(Expression<BigDecimal> in)
		{
			super(in);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return in.evaluate(identifiers).negate();
		}
	}

	public static final class And extends BinaryExpression<Boolean, Boolean, Boolean>
	{
		public And(Expression<Boolean> left, Expression<Boolean> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers) && right.evaluate(identifiers);
		}
	}

	public static final class Or extends BinaryExpression<Boolean, Boolean, Boolean>
	{
		public Or(Expression<Boolean> left, Expression<Boolean> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers) || right.evaluate(identifiers);
		}
	}

	public static final class LessThan extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public LessThan(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) < 0;
		}
	}

	public static final class GreaterThan extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public GreaterThan(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) > 0;
		}
	}

	public static final class LessOrEqual extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public LessOrEqual(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) <= 0;
		}
	}

	public static final class GreaterOrEqual extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public GreaterOrEqual(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) >= 0;
		}
	}

	public static final class Equal extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public Equal(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) == 0;
		}
	}

	public static final class NotEqual extends BinaryExpression<BigDecimal, BigDecimal, Boolean>
	{
		public NotEqual(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final Boolean evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).compareTo(right.evaluate(identifiers)) != 0;
		}
	}

	public static final class Add extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{
		public Add(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).add(right.evaluate(identifiers));
		}
	}

	public static final class Sub extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{
		public Sub(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).subtract(right.evaluate(identifiers));
		}
	}

	public static final class Mul extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{
		public Mul(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).multiply(right.evaluate(identifiers));
		}
	}

	public static final class Div extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{

		private final boolean integerDivision;

		public Div(Expression<BigDecimal> left, Expression<BigDecimal> right, boolean integerDivision)
		{
			super(left, right);
			this.integerDivision = integerDivision;
		}

		public Div(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			this(left, right, true);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			if (integerDivision)
				return left.evaluate(identifiers).divideToIntegralValue(right.evaluate(identifiers));
			else
				return left.evaluate(identifiers).divide(right.evaluate(identifiers));
		}
	}

	public static final class Mod extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{
		public Mod(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).remainder(right.evaluate(identifiers));
		}
	}

	public static final class Pow extends BinaryExpression<BigDecimal, BigDecimal, BigDecimal>
	{
		public Pow(Expression<BigDecimal> left, Expression<BigDecimal> right)
		{
			super(left, right);
		}

		@Override public final BigDecimal evaluate(Map<String, Object> identifiers) throws EvaluationException
		{
			return left.evaluate(identifiers).pow(right.evaluate(identifiers).intValue());
		}
	}

	/**
	 * Evaluates the underlying object in an implementation-specific way and
	 * returns the result.
	 * A subclass <i>may</i> implement lazy evaluation.
	 * @param identifiers mapping between names and values, used by {@link Identifier}
	 * @return the evaluated result
	 * @throws EvaluationException could have multiple reasons, e. g. missing
	 * value for an identifier or division by zero
	 */
	public T evaluate(Map<String, Object> identifiers) throws EvaluationException;
}
